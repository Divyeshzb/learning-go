// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-unit-test using AI Type  and AI Model 

ROOST_METHOD_HASH=uploadFile_4b96457cf9
ROOST_METHOD_SIG_HASH=uploadFile_abff69295f

Scenario 1: Normal operation with a valid file upload

Details:
  Description: This test is meant to check the normal operation of the uploadFile function. It aims to confirm correct file upload when everything is in order, covering the scenario where a user uploads a valid file correctly through the web form.

Execution:
  Arrange: Create a mocked http request with a valid multipart file form data, and a mocked http.ResponseWriter.
  Act: Invoke the uploadFile function with the http.ResponseWriter and http.Request as parameters.
  Assert: Use Go testing facilities to verify that no errors have been encountered during file parsing and upload, that the correct messages are printed, and the response to the user is the success message.

Validation:
  Explanation: This test is asserting whether the function can successfully upload a file under normal conditions. It checks whether the correct output messages are generated, indicating successful file upload and no errors during operation. This is a crucial test, as it checks the core functionality of the function in question under normal operation. The application's ability to upload files is a key business requirement.


Scenario 2: Operation with no file uploaded

Details:
  Description: This test is meant to check the function's response when no file is uploaded, targeting the edge case where a user submits the form without choosing a file.

Execution:
  Arrange: Execute with a mocked http request, but without attaching a file to the request and a mocked http.ResponseWriter.
  Act: Invoke the uploadFile function, passing the http.ResponseWriter and the http.Request.
  Assert: Use Go testing facilities to verify the function returns the correct error messages, and the file parsing and upload is not attempted.

Validation:
  Explanation: This test checks the function’s resilience to an edge case where the user doesn't upload a file and if it can detect it. This contributes to the robustness of the upload functionality, as it ensures the application behaves correctly even when faced with wrong user input.

Scenario 3: Operation with a file exceeding allowed size

Details:
  Description: This test is meant to test the function's response when an uploaded file exceeds the allowed size, checking whether it can handle this exception.

Execution:
  Arrange: Create a mocked http request with a file form data exceeding the allowed size and a mocked http.ResponseWriter.
  Act: Invoke the uploadFile function with the http.ResponseWriter and the oversize http.Request as parameters.
  Assert: Use Go testing facilities to verify that the function returns the correct error messages indicating the file is too large, and further upload operations are not attempted.

Validation:
  Explanation: This test is asserting the function’s reaction to a file that's too large for upload. It's important to ensure that the function behaves as expected when the input doesn't meet the requirements, as it safeguards the application against potential misuse and enhances its reliability.
*/

// ********RoostGPT********
package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
)

func TestUploadFile(t *testing.T) {

	// Scenario 1: Normal operation with a valid file upload
	t.Run("valid file upload", func(t *testing.T) {
		//Arrange
		file := createTempFileWithSize(t, "valid.txt", 10)
		body, writer := createMultipartForm(t, file.Name())
		req := httptest.NewRequest(http.MethodPost, "http://upload-file.test", body)
		req.Header.Set("Content-Type", writer.FormDataContentType())

		w := httptest.NewRecorder()

		//Act
		uploadFile(w, req)

		//Assert
		if w.Code != http.StatusOK {
			t.Errorf("Expected StatusCode 200 but received %d", w.Code)
		}

		if w.Body.String() != "Successfully Uploaded File\n" {
			t.Errorf("Unexpected body %s", w.Body.String())
		}
	})

	// Scenario 2: Operation with no file uploaded
	t.Run("no file uploaded", func(t *testing.T) {
		//Arrange
		req := httptest.NewRequest(http.MethodPost, "http://upload-file.test", nil)
		w := httptest.NewRecorder()

		//Act
		uploadFile(w, req)

		//Assert
		if w.Code != http.StatusOK {
			t.Errorf("Expected StatusCode 200 but received %d", w.Code)
		}

		if w.Body.String() != "" {
			t.Errorf("Unexpected body %s", w.Body.String())
		}
	})

	// Scenario 3: Operation with a file exceeding allowed size
	t.Run("oversized file upload", func(t *testing.T) {
		//Arrange
		file := createTempFileWithSize(t, "oversized.txt", 20<<20) // 20MB, over the limit
		body, writer := createMultipartForm(t, file.Name())
		req := httptest.NewRequest(http.MethodPost, "http://upload-file.test", body)
		req.Header.Set("Content-Type", writer.FormDataContentType())

		w := httptest.NewRecorder()

		//Act
		uploadFile(w, req)

		//Assert
		if w.Code != http.StatusInternalServerError {
			t.Errorf("Expected StatusCode 500 but received %d", w.Code)
		}

		if w.Body.String() != "multipart: NextPart: http: request body too large\n" {
			t.Errorf("Unexpected body %s", w.Body.String())
		}
	})
}

func createTempFileWithSize(t *testing.T, filename string, size int64) *os.File {
	t.Helper()

	file, err := os.CreateTemp("", filename)
	if err != nil {
		t.Fatalf("Could not create temporary file %v", err)
	}

	if err := file.Truncate(size); err != nil {
		t.Fatalf("Could not truncate file %v", err)
	}

	return file
}

func createMultipartForm(t *testing.T, filename string) (io.Reader, *multipart.Writer) {
	t.Helper()

	body := new(bytes.Buffer)
	writer := multipart.NewWriter(body)

	file, err := os.Open(filename)
	if err != nil {
		t.Fatalf("Could not open file %v", err)
	}
	defer file.Close()

	part, err := writer.CreateFormFile("myFile", filename)
	if err != nil {
		t.Fatalf("Could not create form file %v", err)
	}

	if _, err := io.Copy(part, file); err != nil {
		t.Fatalf("Could not copy file to form file %v", err)
	}

	if err := writer.Close(); err != nil {
		t.Fatalf("Could not close multipart writer %v", err)
	}

	return body, writer
}
